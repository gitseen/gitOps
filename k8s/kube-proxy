kube-proxy运行在所有节点上，它监听apiserver中service和endpoint的变化情况，创建路由规则以提供服务IP和负载均衡功能。
简单理解此进程是Service的透明代理兼负载均衡器，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上

当在kubernetes集群中创建一个service对象后，controller-manager组件会自动创建一个和service名称相同的endpoints对象。
endpoints对象中的IP就是该service通过labelSelector关联的且已就绪pod IP，controller-manager里的endpoints controller会监听pod的状态，实时维护endpoints对象中的数据。

kube-proxy在kubernetes集群中以daemonSet形式启动，也就每个节点上都会启动一个kube-proxy服务的pod。
kube-proxy的pod通过监听集群中service和endpoints资源的变化，刷新节点上的iptables/ipvs规则，从而实现访问service VIP代理到后端pod的功能。

三种模式
kube-proxy先后出现了三种模式：userspace、iptables、ipvs，其中userspace模式是通过用户态程序实现转发，因性能问题基本被弃用，当前主流的模式是iptables和ipvs。
kube-proxy默认配置是iptables模式，可以通过修改kube-system命名空间下名称为kube-proxy的configMap资源的mode字段来选择kube-proxy的模式。
kube-proxy iptables模式实现的普通clusterIP类型的service原理，其它类型的service原理大家可以参考本文和其它资料自行分析。
如无特殊场景，下文不再对kube-proxy模式和service类型做特别说明。
原文链接：https://blog.csdn.net/summer_fish/article/details/124267851



kubectl get pod -n kube-system | grep kube-proxy |awk '{system("kubectl delete pod "$1" -n kube-system")}'


 #然后编辑这些 ConfigMap，将旧 IP 替换成新的 IP(将oldip更改为newip)
   kubectl -n kube-system edit cm kubeadm-config
   kubectl -n kube-system edit cm kube-proxy
   systemctl restart docker && systemctl restart kubelet.service
https://www.cnblogs.com/houchaoying/p/14185477.html
